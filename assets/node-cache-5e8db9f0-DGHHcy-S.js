const h=async(i,a,s,l)=>{const o=i.split(s.sep).filter(Boolean),n=o[o.length-1],e=o[0];let t=i;a.existsSync(s.join(s.sep,e))||(t=s.join(l.tmpdir(),n));try{a.mkdirSync(t,{recursive:!0})}catch(r){throw new Error(`Failed to create cache directory: ${r.message}`)}return t},d=async i=>{const a=require("node:fs"),s=require("node:path"),l=require("node:os"),{createHash:o}=require("node:crypto"),n=await h(i,a,s,l);return{makeKey:e=>{const t=e&&e instanceof Object?JSON.stringify(e):e||"";return o("sha256").update(t).digest("hex")},get:async e=>{let t;const r=`${n}/${e}`;try{const c=await a.promises.readFile(r,"utf-8");t=JSON.parse(c)}catch(c){c.code!=="ENOENT"&&console.error(`Failed to read cache file to ${r}: ${c.message}`)}return t},set:async(e,t)=>{const r=`${n}/${e}`;try{await a.promises.writeFile(r,JSON.stringify(t),{encoding:"utf-8",flag:"wx"})}catch(c){c.code!=="EEXIST"&&console.error(`Failed to write cache file to ${r}: ${c.message}`)}}}};export{d as NodeCache,h as makeCacheDir};
